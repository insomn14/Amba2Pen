import requests
import argparse
import warnings
import logging
import colorlog
from urllib3.exceptions import InsecureRequestWarning

# Suppress SSL warnings
warnings.simplefilter('ignore', InsecureRequestWarning)

def make_request(method, url, headers, body, proxy=None):
    if proxy:
        proxies = {
            'http': proxy,
            'https': proxy
        }
        return requests.request(method, url, headers=headers, data=body, proxies=proxies, verify=False, timeout=20)
    else:
        return requests.request(method, url, headers=headers, data=body, verify=False, timeout=20)

def convert_raw_http_to_requests(file_path, conn, custom_headers, proxy=None):
    with open(file_path, 'r') as file:
        raw_request = file.readlines()

    # Extract the request line (method, URL, and HTTP version)
    request_line = raw_request[0].strip()
    method, url, _ = request_line.split()

    # Extract the headers
    headers = {}
    for line in raw_request[1:]:
        line = line.strip()
        if line == '':
            break
        key, value = line.split(':', 1)
        headers[key.strip()] = value.strip()

    # Update headers with custom headers
    headers.update(custom_headers)

    # Extract the body if it exists
    body = None
    if '\n\n' in raw_request:
        body = '\n\n'.join(raw_request.split('\n\n')[1:]).strip()

    # Full URL
    full_url = conn + headers['Host'] + url

    # Make the request
    response = make_request(method, full_url, headers, body, proxy)

    return method, full_url, headers, body, response

def inject_headers(method, full_url, headers, body, header_inject, proxy=None):
    logging.info("Header Injection Testing")
    for key in headers.keys():
        if key.lower() == 'host':
            continue
        injected_headers = headers.copy()
        injected_headers[key] = header_inject
        response = make_request(method, full_url, injected_headers, body, proxy)
        logging.info(f"Injected Request Headers: ({key})")
        #logging.debug(f"Injected Request ({key}) - Response Text: {response.text}")

"""
List of Unwanted HTTP Methods:
  - TRACE: Can be used in Cross-Site Tracing (XST) attacks to steal information like cookies and headers.
  - TRACK: Similar to TRACE, this method can be used to perform XST attacks.
  - OPTIONS: While this method is used to determine the communication options available on the web server, it can reveal information about the server that might be useful to an attacker.
  - PUT: Allows clients to upload files or replace existing files on the server, which can be dangerous if not properly authenticated and validated.
  - DELETE: Allows clients to delete files or resources on the server, which can lead to data loss or application malfunction.
  - CONNECT: Can be used to establish network connections to other resources, potentially tunneling malicious traffic.
  - PATCH: Allows partial modifications to resources, which can be exploited if not properly authenticated and authorized.
  - PROPFIND: Part of the WebDAV protocol, this method can be used to list properties of resources, which might reveal sensitive information.
  - PROPPATCH: Part of the WebDAV protocol, allows the setting of properties on resources, which can be misused.
  - MKCOL: Part of the WebDAV protocol, used to create collections (directories), which can be exploited for creating unwanted directories.
  - COPY: Part of the WebDAV protocol, can be used to copy files or resources, potentially leading to unauthorized duplication of data.
  - MOVE: Part of the WebDAV protocol, allows moving resources, which can lead to data being misplaced or overwritten.
  - LOCK: Part of the WebDAV protocol, used to lock resources, potentially causing denial of service or unauthorized locking of resources.
  - UNLOCK: Part of the WebDAV protocol, used to unlock resources, potentially leading to unauthorized unlocking.

Recommendation:
    The common non-vulnerable response for all these methods is:
    ```
	HTTP/1.1 405 Method Not Allowed
	Allow: GET, POST, HEAD
    ```
"""
def check_unwanted_http_methods(method, full_url, headers, body, proxy=None):
    logging.info("Unwanted HTTP Method Check")
    unwanted_methods = ["TRACE", "TRACK", "OPTIONS", "PUT", "DELETE", "CONNECT", "PATCH", "PROPFIND", "PROPPATCH", "MKCOL", "COPY", "MOVE", "LOCK", "UNLOCK"]
    for unwanted_method in unwanted_methods:
        response = make_request(unwanted_method, full_url, headers, body, proxy)
        #logging.debug(f"Method: {unwanted_method}\nStatus Code: {response.status_code} {response.reason}\nResponse Length: {len(response.content)}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Convert a raw HTTP request to a Python requests call")
    parser.add_argument('file_path', type=str, help="Path to the file containing the raw HTTP request")
    parser.add_argument('--unsecure', action='store_true', help="Use HTTP instead of HTTPS")
    parser.add_argument('--header', action='append', help="Custom header in the form key:value. Can be used multiple times.")
    parser.add_argument('--hInject', type=str, help="Header value to inject into each header one by one")
    parser.add_argument('--proxy', type=str, help="Proxy server (e.g., http://proxy.example.com:8080)")
    parser.add_argument('--unwanted_http_check', action='store_true', help="Check unwanted HTTP methods")
    parser.add_argument('--log_level', type=str, default='DEBUG', help="Set the logging level (e.g., DEBUG, INFO, WARNING, ERROR, CRITICAL)")

    args = parser.parse_args()
    file_path = args.file_path
    conn = "http://" if args.unsecure else "https://"

    # Set the logging level based on the argument
    log_level = getattr(logging, args.log_level.upper(), logging.DEBUG)
    
    # Configure logging with color
    log_colors = {
        'DEBUG': 'blue',
        'INFO': 'yellow',
        'WARNING': 'magenta',
        'ERROR': 'red',
        'CRITICAL': 'red'
    }
    formatter = colorlog.ColoredFormatter(
        '[%(yellow)s%(asctime)s%(reset)s] [%(log_color)s%(levelname)s%(reset)s] %(white)s%(message)s%(reset)s',
        datefmt='%H:%M:%S',
        log_colors=log_colors,
    )
    handler = colorlog.StreamHandler()
    handler.setFormatter(formatter)
    logger = logging.getLogger()
    logger.addHandler(handler)
    logger.setLevel(log_level)

    # Parse custom headers
    custom_headers = {}
    if args.header:
        for header in args.header:
            key, value = header.split(':', 1)
            custom_headers[key.strip()] = value.strip()

    method, full_url, headers, body, response = convert_raw_http_to_requests(file_path, conn, custom_headers, args.proxy)

    # Print the response
    #logging.debug(f"Request - Status Code: {response.status_code} {response.reason}")
    #logging.debug(f"Request - Response Length: {len(response.content)}")

    # Inject headers if the hInject argument is provided
    if args.hInject:
        inject_headers(method, full_url, headers, body, args.hInject, args.proxy)

    # Check unwanted HTTP methods if the unwanted_http_check argument is provided
    if args.unwanted_http_check:
        check_unwanted_http_methods(method, full_url, headers, body, args.proxy)
